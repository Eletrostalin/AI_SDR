from db.segmentation import EMAIL_SEGMENT_COLUMNS


def generate_column_mapping_prompt(user_columns: list) -> str:
    """
    Формирует текстовый промпт для сопоставления колонок.

    :param user_columns: Список колонок, загруженных из файла пользователя.
    :return: Текстовый промпт.
    """
    return (
        f"У нас есть фиксированный список колонок: {', '.join(EMAIL_SEGMENT_COLUMNS)}.\n"
        f"Пользователь загрузил таблицу со следующими колонками: {', '.join(user_columns)}.\n"
        f"\n"
        f"**Твоя задача**:\n"
        f"1. Сопоставить КАЖДУЮ колонку пользователя с одним из фиксированных полей.\n"
        f"2. **Не добавляй колонки, которых нет в загруженной таблице**.\n"
        f"3. **Не пытайся догадываться** и не создавай лишние поля.\n"
        f"4. Если колонка пользователя не соответствует ни одному из фиксированных полей, укажи null.\n"
        f"\n"
        f"**Формат ответа (JSON, без текста перед ним!)**:\n"
        f"```json\n"
        f"{{\n"
        f"  \"колонка пользователя\": \"соответствующая колонка\",\n"
        f"  \"колонка пользователя\": null\n"
        f"}}\n"
        f"```\n"
        f"\n"
        f"**Пример:**\n"
        f"Если пользователь загрузил колонки `Email` и `Сайт`, а других колонок нет, то ответ должен быть:\n"
        f"```json\n"
        f"{{\n"
        f"  \"Email\": \"email\",\n"
        f"  \"Сайт\": \"website\"\n"
        f"}}\n"
        f"```\n"
        f"\n"
        f"Если в загруженном файле есть только `Контактное лицо`, и оно не совпадает с нашими колонками, то ответ будет:\n"
        f"```json\n"
        f"{{\n"
        f"  \"Контактное лицо\": null\n"
        f"}}\n"
        f"```\n"
        f"\n"
        f"**Важно:**\n"
        f"- В файле пользователя может быть только 1-2 колонки, не больше.\n"
        f"- Если колонка не найдена в нашем списке, она должна быть `null`, а не заменяться на похожее значение.\n"
    )